# コマンドライン・インターフェイス・ガイドライン

よりよいコマンドライン・プログラムを書くための [オープンソース](https://github.com/cli-guidelines/cli-guidelines) のガイド。伝統的なUNIXの原則を元に、現代版にアップデートしています。  

## 著者 {#authors}

**Aanand Prasad** \
Engineer at Squarespace, co-creator of Docker Compose. \
[@aanandprasad](https://twitter.com/aanandprasad)

**Ben Firshman** \
Co-creator [Replicate](https://replicate.ai/), co-creator of Docker Compose. \
[@bfirsh](https://twitter.com/bfirsh)

**Carl Tashian** \
Developer Advocate at [Smallstep](https://smallstep.com/), first engineer at Zipcar, co-founder Trove. \
[tashian.com](https://tashian.com/) [@tashian](https://twitter.com/tashian)

**Eva Parish** \
Technical Writer at Squarespace, O’Reilly contributor.\
[evaparish.com](https://evaparish.com/) [@evpari](https://twitter.com/evpari)

Design by [Mark Hurrell](https://mhurrell.co.uk/). Thanks to Andreas Jansson for early contributions, and Andrew Reitz, Ashley Williams, Brendan Falk, Chester Ramey, Dj Walker-Morgan, Jacob Maine, James Coglan, Michael Dwan, and Steve Klabnik for reviewing drafts.

<iframe class="github-button" src="https://ghbtns.com/github-btn.html?user=cli-guidelines&repo=cli-guidelines&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>

[Join us on Discord](https://discord.gg/EbAW5rUCkE) if you want to discuss the guide or CLI design.


## はじめに {#foreword}

1980年代には、パーソナル・コンピュータに何かやらせようと思ったら、`C:\>` とか `~$` を前にして、何をタイプすればいいか知っている必要があった。
ヘルプといえるのは、リング綴じの分厚いマニュアルだけ。
エラーメッセージは意味不明。
頼りになる Stack Overflow もまだなかった。
だが、運よくインターネットにつなぐことさえできれば、Usenet（初期のインターネット・コミュニティで、同じような不満を抱える人で満ち溢れていた）の力を借りることができた。
問題解決を助けてくれることもあったし、少なくとも、精神的な支えになったり、仲間意識を持たせてはくれた。

それから40年経って、コンピュータは誰にとっても、ずっと近づきやすいものになった。それと引き換えに、低レベルのユーザーコントロールは割愛されることが多い。
多くのデバイスでは、そもそもコマンドラインでアクセスする手段がない。排他的な箱庭とアプリストアによってもたらされる企業の利益に反するから、というのもその一因だろう。

今ではほとんどの人がコマンドラインが何かを知らない。わざわざそれを使いたいと思う理由など、なおのことない。
コンピュータ界のパイオニア Alan Kay は、[2017 年のインタビュー](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now) でこう言っている。「コンピューティングとは何か、ということがわかっていないから、iPhone にそれが入っていると思ったりするわけだけど、こうした勘違いは『Guitar Hero』とホンモノのギターを同じだと考えるくらい、たちの悪い勘違いだ」

Kay にとっての「ホンモノのギター」とは、厳密に言うと CLI ではない。
彼が言うのは CLI のパワーを備えつつ、ソフトウェアをテキストファイルで書くというやり方を超えたコンピュータ・プログラミングのあり方だ。
Kay の一派の間では、何十年も続いてきたテキストをベースにした局所的な最適化から開放されるべきだ、という信念がある。

将来、どれほど変わったやり方でコンピュータをプログラムするようになるのか、想像するのは楽しい。
今すでに、スプレッドシートはぶっちぎりで人気のあるプログラム言語だし、ノーコードの動きも急速に盛り上がっている。才能あるプログラマに集中する需要の一部をこれで代替できるのでは、と見込まれているからだ。

何十年来の制約からあちこちガタがきて、いわく言い難いクセを持ちながらも、コマンドラインは今なお、コンピュータのもっとも _多才な_ 一面を見せてくれる。
カーテンを開けて、物事の状況を見きわめ、マシンと創造的にやりとりする。こうしたことが、GUIには不可能な精巧さ、深さでできるのだ。
ほとんどどんなラップトップにも入っていて、学ぶ気持ちさえあれば、誰にでも利用できる。
対話的に使うことも、自動化することもできる。
さらに、システムの中では、他の部分よりも陳腐化しにくい。
安定性の中に創造的な価値があるのだ。

というわけで、まだ手元にあるうちは、その利便性とアクセシビリティを最大限に活用すべきだろう。

コンピュータのプログラム方法も、黎明期のころとはずいぶん変わった。
かつてのコマンドラインは _マシン・ファースト_ 、スクリプト環境の上に構築されたREPLに毛の生えたようなものでしかなかった。
だが、汎用のインタープリター言語が繁栄するにつれて、シェルスクリプトの役割は小さくなっていった。
現代のコマンドラインは  _ヒューマン・ファースト_ 、あらゆる種類のツール、システム、プラットフォームへのアクセスを可能にするテキストベースのUIである。
かつては、エディタはターミナルの中で起動した。今では、ターミナルは、エディタの中の一機能になっていることも多い。
また、`git` 的な、マルチツール型のコマンドが増えている。
コマンドの中のコマンド、個々の機能だけでなく、ワークフロー全体をカバーできるハイレベルのコマンドである。

伝統的なUNIXの哲学に触発され、CLI環境をより楽しく、アクセシブルなものにしようという意図のもと、プログラマとしての自分たちの経験を元に、コマンドライン・プログラム作成のベストプラクティスと設計原則を改めてまとめておくことにした。

コマンドラインよ、永遠なれ！

## 序論 {#introduction}

この文書では、ハイレベルの設計原則と具体的なガイドラインの両方をカバーする。
ガイドラインの方が厚みがあるが、それは「原理原則にこだわりすぎるな」という実践家としての原理原則に起因している。
実例がある方がわかりやすいと信じているので、たくさんの実例を掲載した。

このガイドでは、emacs や vim のような、フルスクリーンの端末プログラムは扱わない。
フルスクリーン・プログラムはニッチなプロジェクトで、その種のものを設計する立場になることはめったにないからだ。

また、このガイドでは、基本的にプログラム言語やツールについてはこだわらない。

このガイドはどういう人に向いているか？
- CLI プログラムを作っていて、UIデザインに関する原則や具体的なベストプラクティスを求めている人。このガイドはあなた向きである。
- プロの「CLI UI デザイナー」。すごいですね。ぜひお説をお伺いしたいものです。
- 40 年にわたるCLIデザインのお作法として当たり前とされてきたようなことを踏み外さないようにしたい人。このガイドはあなた向きである。
- 優れたデザインと役に立つヘルプを備えたプログラムでみんなを喜ばせたい人。このガイドはまさにあなた向きである。
- GUI プログラムを作る人。このガイドはあなた向きでない。ただ、それでも目を通してもらえるなら、GUI のアンチパターンを学べるかもしれない。
- 没入型のフルスクリーン CLI に Minecraft を移植したい人。このガイドはあなた向きでない。
（でも、ぜひ見てみたい！）

## 原理原則 {#philosophy}

私たちの考える優れたCLIデザインの基本原則は以下の通り。

## ヒューマン・ファーストのデザイン {#human-first-design}

伝統的に、UNIX のコマンド群は、主として他のプログラムから使われることを前提に書かれている。
グラフィカルなアプリケーションというよりは、プログラム言語の関数に近いものだ。

今では、多くの CLI プログラムは主として（あるいは例外なく）人間が使っているにも関わらず、そのインタラクション・デザインは過去の遺物を引きずっている。
そろそろ、こうした遺物を切り捨てる時だ。そのコマンドが使うのが主として人間であるのなら、ヒューマン・ファーストのデザインにすべきだ。

### 連携して動作するシンプルな部品 {#simple-parts-that-work-together}

[もともとの UNIX 原則](https://en.wikipedia.org/wiki/Unix_philosophy) が掲げる根本信条は、小さく、シンプルなプログラムに、クリーンなインターフェイスを持たせ、それらの組み合わせで大きなシステムを構築しようという発想だ。
ひとつのプログラムにどんどん機能を詰め込むのではなく、組み合わせ可能なようにモジュール化したプログラムを作るわけである。

昔は、プログラムを作成する上で、パイプやシェルスクリプトが果たす役割は非常に大きかった。
汎用のインタープリター言語の登場で、その役割は縮小したかもしれないが、完全に消滅したわけではないのは確かだ。
さらにいうと、大規模オートメーション、CI/CDという形でのオーケストレーションと構成管理は隆盛をみている。
プログラムを組み込みできるようにしておくことは、今もなお重要だ。

幸運にも、長年にわたって確立された UNIX 環境のお作法は、まさにこうした目的のために設計されていて、今もなお役に立つ。
標準入力／出力／エラー、シグナル、終了コード等々といった仕組みで、異なるプログラムをうまく連動させることができる。
行志向のプレーンテキストは、パイプによるコマンド間の受け渡しが容易だ。
JSONはずっと最近の発明だが、必要に応じてより高度な構造を可能にしてくれる。コマンドライン・ツールとウェブの連携も簡単になる。

どんなツールを書いているにせよ、それが予想もしない使われ方をすることは確実だ。
あなたのツールが、より大きなシステムの一部になるのは _間違いない_。その時に与えられる選択肢は、扱いやすいパーツになるかどうかだけ。

一番大事なのは、組み込みを意識したデザインと、ヒューマン・ファーストのデザインは、必ずしも相容れないものではない、ということだ。
この文書に掲載したアドバイスの多くは、これを実現する方法に関するものだ。

### プログラム間の一貫性 {#consistency-across-programs}

ターミナルのお作法は私たちの指に染み込んでいる。
コマンドラインのシンタックス、フラグ、環境変数などを学習するという前払いを要求されるが、長期的な効率という面では見合うものだ…プログラム間に一貫性があれば、の話だが。

可能な限り、CLI は既存のパターンに従うべきだ。
そうすれば、CLIは直感的で予測可能になり、ひいてはユーザの効率につながる。

とはいうものの、ときには一貫性と使いやすさが両立しないこともある。
たとえば、長らく定番となっている UNIX コマンド群は、デフォルトではわずかな情報しかアウトプットしない。コマンドラインに馴染みのない人にとっては、混乱と不安のもとになりかねない。

以下のお作法がプログラムのユーザビリティを下げている場合、離脱すべきときかもしれない—だたし、この種の決断は慎重に。

### 最低限十分なメッセージ {#saying-just-enough}

ターミナルは純粋な情報の世界だ。
情報こそインターフェイスだ、という主張もありうる—そしてまた、どんなインターフェイスでもそうだが、うるさすぎる場合と、静かすぎる場合がある。

何分も止まったままで、壊れてるんじゃないかとユーザが心配しだすようなら、そのコマンドは静かすぎる。
デバッグ用のアウトプットが延々と吐き出され、本当に重要なものがゴミの中に埋もれてしまうようなら、そのコマンドはうるさすぎる。
いずれも結果は同じ：明快さに欠け、ユーザを混乱させ、イライラさせてしまう。

このバランスをとるのが実に難しい場合がある。だが、ユーザに力を授け、助けになるソフトウェアにするためには、絶対に欠かせないことだ。

### 発見のしやすさ {#ease-of-discovery}

機能を見つけやすくするという点では、GUI が一枚上手だ。
できることがすべて目の前の画面上に並んでいるから、何も勉強しなくても必要なものが見つけられるし、予想外の機能だって見つかるかもしれない。

コマンドライン・インターフェイスはこの正反対だと思われている。どんなやり方もすべて覚えておかなくてはならないと。
1987年に出た最初の [Macintosh Human Interface Guidelines](https://archive.org/details/applehumaninterf00appl) では、「見て指差す（覚えてタイプするではなく）」方式を推奨している。それがあたかも二択問題であるかのように。

この両者は必ずしも排他的とは限らない。
コマンドラインの効率性はコマンドを記憶することで実現されるが、コマンドの学習や記憶を補助することだってできるはずだ。

発見のある CLI には総合的なヘルプ文があり、たくさんの実例を備えていて、エラーの際には対処法を示してくれる。
GUI には、たとえ相手がパワーユーザであっても、CLI を学びやすく、使いやすいものにするためのヒントがたくさん詰まっている。

_Citation: The Design of Everyday Things (Don Norman), Macintosh Human Interface Guidelines_

### 対話が基本 {#conversation-as-the-norm}

GUIデザインでは、特にその初期に _メタファー_ が頻繁に用いられた。デスクトップ、ファイル、フォルダ、ゴミ箱など。
これは非常に納得がいく。なぜならコンピュータはまだ居場所を求めてもがいていた時期だったからだ。
メタファーが実装しやすいという点は、GUIがCLIに大きく勝ることのひとつだ。
だが皮肉なことに、CLIはずっと意図しないメタファーを体現し続けてきた。それは対話だ。

ごくシンプルなコマンドを除けば、プログラムを起動するには一度のやり取りではすまない。
普通、それは一度で正解を出すことが難しいからだ。ユーザがコマンドをタイプする。エラーが出る。コマンドを変える。また別のエラーが出る、といった感じで、うまくいくまで続く。
失敗の連続から学習するという形態は、ユーザがプログラムと交わす対話に似ている。

だが、トライアル・アンド・エラーだけが対話式インターフェイスとは限らない。
他にもこのようなものがある：

- あるコマンドでツールを設定したあと、実際の利用にはどういうコマンドを使うのかを学習する。
- オペレーションの準備にいくつかコマンドを使い、最後に実行用のコマンドを叩く（例：`git add` を何回か叩いたあと、`git commit` する）。
- システムの探索ー例えば、`cd` や `ls` を使いまくってディレクトリ構造を把握する、とか、`git log` や `git show` でファイルの履歴を調べる。
- 複雑なオペレーションを実行する前に dry-run する。

コマンドライン・インタラクションには対話的な性質があると認めるということは、すなわち、そのデザインに必要なテクニックを取り入れるということだ。
ユーザが不適切な入力をしたら修正候補をサジェストしたり、複数ステップのプロセスを踏むときは、中間点を明確にするとか、あぶない操作をする前に、本当に大丈夫か確認するといったことだ。

あなたが意図するかどうかに関わらず、ユーザはソフトウェアと対話している。
最悪の場合、その対話は敵意あるものになって、ユーザをバカにし、怒らせることになってしまう。
最善の場合、その対話は好ましいものになり、ユーザをより早く未知の知識に導き、達成感を得てもらうことができる。

_参考資料: [The Anti-Mac User Interface (Don Gentner and Jakob Nielsen)](https://www.nngroup.com/articles/anti-mac-interface/)_

### 堅牢性 {#robustness-principle}

堅牢性は客観的かつ主観的な特性だ。
当たり前だが、ソフトウェアは堅牢でなければならない：予期外の入力があってもうまく扱えるとか、可能な限り、操作に冪等性がある、といったことだ。
だが、同時にそれは堅牢な _手応え_ も与えなくてはならない。

自分のソフトウェアが脆いとは思われなくないだろう。
打てば響く反応のよいソフトウェアと思ってもらいたいだろう。ペラペラの「ソフト・スイッチ」ではなく、巨大な機械式のマシンであるかのごとく。

主観的な堅牢性を持たせるには細部への配慮が欠かせない。また、どんな落とし穴がありうるかについて、想像力も必要だ。
細かいポイントがたくさんある：今起こっていることについてユーザにこまめに知らせる。よくあるエラーについてその意味を説明する。不気味な印象のスタックトレースは表示しない。

一般則として、堅牢性はシンプルさを保つことからももたらされる。
特殊な例外や、複雑なコードがたくさんあるプログラムは脆弱になる。

### 共感 {#empathy}

コマンドライン・ツールは、プログラマの創造的なツールキットだから、使っていて楽しいものであるべきだ。
だからといって、何もビデオゲームにしたり、絵文字をたくさん使えばいいというわけではない（もっとも、絵文字自体に罪はないのだが 😉）。
それは、ユーザの味方であると感じてもらうことであり、ユーザの成功のために、問題点について、解決方法について、よく考えてあると感じてもらうことである。

ユーザの味方だと感じてもらうための決まった行動リストがあるわけではない。だが、私たちのアドバイスにしたがうことで、いくらかでもその方向に進んでもらうことができればうれしい。
ユーザに喜んでもらうとは、随所で _彼らの期待を超える_ ことを意味する。それは共感から始まる。

### カオス {#chaos}

ターミナルの世界はとっ散らかっている。
一貫性がないのは当たり前で、私たちは足を引っ張られ、自信がゆらぐこともある。

とはいえ、このカオスがパワーの源であることも否定できない。
ターミナルは、UNIX由来のコンピュータ環境が概してそうであるように、作るものに制限を設けることはごくまれである。
このような空間で、ありとあらゆる発明が花開く。

皮肉なことに、この文書では既存のパターンに従うことを推奨しているが、何十年ものコマンドラインの伝統とは矛盾するアドバイスだ。
私たちも、ルールを破ることにかけては、他のみんなと同じスネの傷を持つ。

いつかあなたもまた、ルールを破らざるをえない時が来るだろう。
やるなら、はっきりとした意図と、明確な目的を持ってやることだ。

> 「生産性とユーザの満足度が明らかに損なわれているときは、常識を捨てるべきである。」 — Jef Raskin, [The Humane Interface](https://en.wikipedia.org/wiki/The_Humane_Interface)

## ガイドライン {#guidelines}

コマンドライン・プログラムをよくするためにできることを、以下、具体的にまとめた。

最初のセクションには、絶対に守るべきことが入っている。
ここを間違うと、プログラムは使いにくくなるか、あるいはCLIの一員として失格になる。

それ以外は、あればなお良し、という項目だ。
これらを取り入れる時間とエネルギーがあれば、平均的なプログラムよりはるかにできのよいプログラムになるだろう。

発想としては、プログラムのデザインを考え抜く気がないなら、それでもよい、というものだ。ここのルールを守っていれば、たぶん、よいプログラムができるだろう。
一方、自分で考えた結果、あるルールが自分のプログラムには当てはまらないと言い切れるなら、それもよい。
（専制的なルールを守らなかったからと言って、あなたのプログラムを断罪できる権力者はいない）

同様に—これらのルールは石に刻まれたものでもない。
ちゃんとした理由があって一般的ルールに納得できないのなら、[変更を提案](https://github.com/cli-guidelines/cli-guidelines)していただけるとありがたい。

### 基本 {#the-basics}

守るべき基本ルールがいくつかある。
ここを間違うと、プログラムは非常に使いにくくなるか、あるいはまったく壊れてしまう。

**できるなら、コマンドライン引数パース用のライブラリを使うべし。**
使用している言語の標準機能か、またはよくできたサードパーティ製。
それらは普通、引数を受け取ってフラグをパースしたり、ヘルプテキストを表示したり、中には気を利かせてスペルの候補を出してくれたりするのが普通だ。

私たちのお気に入りは以下：
* Multi-platform: [docopt](http://docopt.org)
* Bash: [argbash](https://argbash.io)
* Go: [Cobra](https://github.com/spf13/cobra), [cli](https://github.com/urfave/cli)
* Haskell: [optparse-applicative](https://hackage.haskell.org/package/optparse-applicative)
* Java: [picocli](https://picocli.info/)
* Node: [oclif](https://oclif.io/)
* PHP: [console](https://github.com/symfony/console), [CLImate](https://climate.thephpleague.com)
* Python: [Argparse](https://docs.python.org/3/library/argparse.html), [Click](https://click.palletsprojects.com/), [Typer](https://github.com/tiangolo/typer)
* Ruby: [TTY](https://ttytoolkit.org/)
* Rust: [clap](https://clap.rs/), [structopt](https://github.com/TeXitoi/structopt)
* Swift: [swift-argument-parser](https://github.com/apple/swift-argument-parser)

**終了コードは、成功のときゼロ、失敗のときはゼロ以外を返すべし。**
スクリプトは、終了コードをみて、プログラムが成功したかどうかを判断する。よって、これを正確に報告しなければならない。
ゼロ以外のコードは、もっとも重要な失敗モードに割り当てよう。

**出力は `stdout` に出すべし.**
コマンドからのメインの出力は `stdout` （標準出力）にすること。
機械可読なものは何であれ `stdout` へ出す。パイプはここを通してデータをやりとりをするのがデフォルトだ。

**メッセージは `stderr` に出すべし。**
ログメッセージ、エラーなどは、すべて `stdout` に出すこと。
こうすれば、コマンドをパイプでつないだとき、メッセージはユーザに表示されるが、次のコマンドには送信されない。

### ヘルプ {#help}

**オプションが指定されていないとき、 `-h` フラグ、または `--help` フラグがついているときはヘルプ・テキストを表示する。**

**デフォルトで出すヘルプ・メッセージは簡潔に。**
可能であれば、 `myapp` または `myapp subcommand` で起動したときは、デフォルトでヘルプを表示する。
よほどシンプルなプログラムで、デフォルトの機能が明白なもの（例： `ls`）や、対話的に入力を読み込むプログラム（例：`cat`）は例外だ。

簡潔なヘルプには以下の事項だけを入れておく：

- そのプログラムにどんな機能があるかの説明。
- 起動方法の実例を1、2件。
- フラグの説明、大量にある場合は除く。
- 詳しい情報は `--help` フラグで得られることの説明

`jq` はこれがうまくできている。
 `jq` とだけタイプすると、初歩的な説明と実例が表示され、フラグの完全な説明を見たい人は `jq --help` と打つように誘導される：

```
$ jq
jq - commandline JSON processor [version 1.6]

Usage:    jq [options] <jq filter> [file...]
    jq [options] --args <jq filter> [strings...]
    jq [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output.

The simplest filter is ., which copies jq's input to its output
unmodified (except for formatting, but note that IEEE754 is used
for number representation internally, with all that that implies).

For more advanced filters see the jq(1) manpage ("man jq")
and/or https://stedolan.github.io/jq

Example:

    $ echo '{"foo": 0}' | jq .
    {
        "foo": 0
    }

For a listing of options, use jq --help.
```

**`-h` and `--help` が渡されたら完全版のヘルプを表示する。**
以下の場合は、いずれもヘルプを表示する。
 
```
$ myapp
$ myapp --help
$ myapp -h
```

これ以外のフラグや引数は無視。どんなものの後にでも `-h` が付いていたらヘルプを表示すること。
何が来ても `-h` は無効にならない。

 `git` 的なコマンドなら、以下でもヘルプを表示する：

```
$ myapp help
$ myapp help subcommand
$ myapp subcommand --help
$ myapp subcommand -h
```

**フィードバックとバグ報告ためのサポート窓口を作る**
ヘルプ・テキストの上部に、ウェブサイトか、GitHubへのリンクを置くのが通例。

**ヘルプ・テキストに、ウェブ版のドキュメントへのリンクを掲載する**
サブコマンドのページやページ内リンクがあるようなら、ダイレクトにそこへリンクする。
ウェブ上によりくわしいドキュメントがある、あるいは何かの挙動に関する説明がある場合は、これは特に有益だ。

**使用例から始める**
どんな種類のドキュメントよりも、ユーザは使用例を見たがるので、まずはヘルプページの最初に掲載しよう。特によく使われるのに複雑な使い方を載せるとよい。
やっていることがよりわかりやすくなり、しかも長すぎないで済むようなら、出力結果も載せるといい。

実例をいくつも載せることで話を進め、徐々に複雑な使い方へ進んでいくのもいいだろう。
<!-- TK example? -->

**使用例が大量にあるときは別の場所にまとめる**ようにして、チートシートコマンドや、ウェブページで見られるようにしておく。
詳細な上級者向けの実例があると役に立つが、ヘルプ・テキストが長過ぎるのも考えものだ。

より複雑なユースケース、たとえば他のツールとの連携といった話題には、別途、それ向けのチュートリアルを用意することも考慮したい。

**ヘルプ・テキストの冒頭には、もっとも汎用的なフラグとコマンドを掲載する。**
フラグがたくさんあるのはかまわない。だが、その中でもっともよく利用されるものを一番最初に表示しよう。
たとえば、Git コマンドでは、使い始めに用いるコマンドと、最もよく利用されるサブコマンドを最初に表示している：

```
$ git
usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status
…
```

**ヘルプ・テキストは適切に装飾する。**
見出しを太字にしておくと流し読みがしやすい。
だが、ターミナルに依存しない方法を採用するようにしよう。さもないと、ユーザはエスケープ文字の嵐を眺めることになる。

<pre>
<code>
<strong>$ heroku apps --help</strong>
list your apps

<strong>USAGE</strong>
  $ heroku apps

<strong>OPTIONS</strong>
  -A, --all          include apps in all teams
  -p, --personal     list apps in personal account when a default team is set
  -s, --space=space  filter by space
  -t, --team=team    team to use
  --json             output in json format

<strong>EXAMPLES</strong>
  $ heroku apps
  === My Apps
  example
  example2

  === Collaborated Apps
  theirapp   other@owner.name

<strong>COMMANDS</strong>
  apps:create     creates a new app
  apps:destroy    permanently destroy an app
  apps:errors     view app errors
  apps:favorites  list favorited apps
  apps:info       show detailed app information
  apps:join       add yourself to a team app
  apps:leave      remove yourself from a team app
  apps:lock       prevent team members from joining an app
  apps:open       open the app in a web browser
  apps:rename     rename an app
  apps:stacks     show the list of available stacks
  apps:transfer   transfer applications to another user or team
  apps:unlock     unlock an app so any team member can join
</code>
</pre>

注：`heroku apps --help` をページャーにパイプすると、コマンドからはエスケープ文字が出力されなくなる。

**ユーザの誤操作から本当にやりたいことを推測できるときは、サジェストを出す。**
例えば、 `brew update jq` とタイプしてきたら `brew upgrade jq` の挙動をすべきだ。

サジェストしたコマンドを実行したいか確認するのはよいが、強制はいけない。
たとえば：

```
$ heroku pss
 ›   Warning: pss is not a heroku command.
Did you mean ps? [y/n]:
```

修正後のシンタックスをサジェストするだけでなく、それを実行してあげたい誘惑に駆られるかもしれない。そもそもユーザが初めから正しいコマンドを叩いたかのように。
そうすべきときもあるが、常にそうとも限らない。

第一に、無効な入力は必ずしも単純なタイプミスとは限らない。論理的に考えた結果のミスだったり、シェル変数の誤用だったりする場合も少なくない。
危険なことをしようとしている可能性もある。アクションの結果、状態が変わってしまうような場合は特にそうだ。

第二に、ユーザがタイプしたものを勝手に変更してしまうと、正しいシンタックスを学ぶ機会がなくなる点にも注意が必要だ。
実質的に、ユーザがタイプした書式が有効か、正しいかを判断するのはあなただ。一度サポートすると決めた以上は途中で変えてはならない。
しっかりと判断して、両方のシンタックスをドキュメントに記載しておくこと。

_Further reading: [“Do What I Mean”](http://www.catb.org/~esr/jargon/html/D/DWIM.html)_

**パイプ入力を前提としたコマンドに、 `stdin` として対話式ターミナルがつながっているときは、ただちにヘルプを表示して終了する。**
これで `cat` みたいなハングはしなくなる。
もしくは `stderr` にログ・メッセージを出力してもいいだろう。

### ドキュメント {#documentation}

[ヘルプテキスト](#help) の目的は、そのツールが何で、どんなオプションがあって、もっともよくやるタスクはどう実行したらいいのかを、短く簡潔に伝えることにある。
一方、ドキュメントは、詳細を極める場である。
そのツールが目的とすること、目的に _しない_ こと、動作の仕組みや、必要なことすべてのやり方を理解するために参照されるものである。

**ウェブベースのドキュメントを用意する。**
ツールのドキュメントはオンラインで検索でき、他の人に、文中の特定の箇所を指し示せることが求められる。
この点で、ウェブは現状もっとも許容範囲の広いドキュメント形式である。

**ターミナルベースのドキュメントを用意する。**
ターミナル用のドキュメントにはいくつかの利点がある：すばやくアクセスできること、実際にインストールされているツールとバージョンの齟齬がないこと、ネット環境がなくても使えること。

**man ページの提供も考慮する。**
[man ページ](https://en.wikipedia.org/wiki/Man_page) は、UNIX 用の元祖ドキュメントシステムであり、今日もまだ利用されている。ツールについて調べるとき、脊髄反射的にまずは `man mycmd` と打ち込むユーザはたくさんいる。
ドキュメント生成を楽にするには、[ronn](http://rtomayko.github.io/ronn/ronn.1.html) （ウェブドキュメントも同時に生成してくれる）のようなツールを使うとよい。

だが、あらゆる人が `man` を知っているわけではないし、動作しないプラットフォームもある。だから、ツール自体からターミナル用のドキュメントに確実にアクセスできるようにしておくべきだ。
例えば、`git` や `npm` では、`help` サブコマンドから man ページにアクセスできるようになっているので、`npm help ls` は `man npm-ls` と同じことになる。

```
NPM-LS(1)                                                            NPM-LS(1)

NAME
       npm-ls - List installed packages

SYNOPSIS
         npm ls [[<@scope>/]<pkg> ...]

         aliases: list, la, ll

DESCRIPTION
       This command will print to stdout all the versions of packages that are
       installed, as well as their dependencies, in a tree-structure.

       ...
```

### 出力 {#output}

**人間が読める出力が最優先。**
人間が主で、マシンは従である。
出力ストリーム（`stdout` または `stderr`）を読んでいるのが人間かどうかを見分けるための方法として、経験的にもっともシンプルかつ簡単なやり方は、_TTYかどうか_ で判断することである。
このためのユーティリティやライブラリはどんな言語にもある（例： [Python](https://stackoverflow.com/questions/858623/how-to-recognize-whether-a-script-is-running-on-a-tty), [Node](https://nodejs.org/api/process.html#process_a_note_on_process_i_o), [Go](https://github.com/mattn/go-isatty)）。

_[TTY とは何か] についての詳細 (https://unix.stackexchange.com/a/4132)._

**機械可読のアウトプットはユーザビリティを損なわないところで出す。**
テキストのストリームはUNIXの汎用的なインターフェイスとなっている。
プログラムはテキストを出力するのが普通だし、入力として期待するのもまたテキストである。
それで、複数のプログラムを連携させることができるわけだ。
これは、通常、スクリプトを書けるようにすることが目的だが、
プログラムを利用する人間にとってもユーザビリティを高める場合がある。
例えば、出力をパイプで `grep` につなげば、期待通りのことができる。

> 「あらゆるプログラムの出力は、未知のものを含む他のプログラムの入力となることを前提とせよ」
— [Doug McIlroy](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)

**人間可読な出力にすると機械可読な出力が崩れるときは `--plain` でプレーンな表形式のテキストを表示できるようにして、 `grep` や `awk` といったツールと組み合わせられるようにする。**
場合によっては、人間可読にするために、出力情報の書式を変える必要がある。
<!-- (TK example with and without --plain) -->
例えば、行単位のテーブルを表示する場合、ひとつのセルを複数行に分割して、画面幅いっぱいにできるだけ多くの情報を詰め込もうとするような場合だ。
こうすると、1行1データという期待される挙動が変わってしまう。そこで `--plain` フラグを使って、このような整形を停止し、1行1レコードで出力できるようにしておくのである。

**`--json` を渡されたら出力をJSON形式で表示する。**
JSON なら、プレーンテキストをより構造的にできるので、複雑なデータ構造を出力したり、取り扱ったりするのがはるかに楽になる。
[`jq`](https://stedolan.github.io/jq/) は、コマンドラインでJSONを扱う際によく用いられるツールだ。今では JSON を出力したり操作したりするための [網羅的なツールのエコシステム](https://ilya-sher.org/2018/04/10/list-of-json-tools-for-command-line/) が整備されている。

また、JSON はウェブでも広く利用されているので、プログラムの入出力に JSON を採用すれば、 `curl` を使って、ウェブサービスと直接やりとりすることもできる。

**成功したときは出力を、ただし、簡潔に。**
問題ないときは、伝統的に UNIX コマンドはユーザに何も出力しない。
スクリプトの中で利用される場合は納得できる挙動だが、人間が利用するときはハングしたり、壊れたように見える。
例えば、長い時間がかかるときでも `cp` は何も出力しない。

デフォルトの動作として、何も出力しないのがベストだと言える状況はめったにない。だが、だいたいにおいて簡素すぎるくらいでちょうどいい。

まったく出力が不要な場合は（たとえば、シェルスクリプトの中で利用する場合）、 `stderr` を `/dev/null` にリダイレクトする手間を省くために、 `-q` オプションを設けて、重要でない出力はすべて抑止するようにする。

**状態が変わるときはユーザに告知する。**
コマンドがシステムの状態を変えるときは、何が起こったのか説明することが特に役に立つ。ユーザが頭の中でシステムの状態を思い描くことができるからだ。ユーザが求めていたものと実際の結果が直接対応していない場合は特にそうである。

例えば、`git push` は、今何をしているのか、リモートのブランチが新しくどういう状態になったのかを正確に説明している：

```
$ git push
Enumerating objects: 18, done.
Counting objects: 100% (18/18), done.
Delta compression using up to 8 threads
Compressing objects: 100% (10/10), done.
Writing objects: 100% (10/10), 2.09 KiB | 2.09 MiB/s, done.
Total 10 (delta 8), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (8/8), completed with 8 local objects.
To github.com:replicate/replicate.git
 + 6c22c90...a2a5217 bfirsh/fix-delete -> bfirsh/fix-delete
```

**システムの現在の状態をわかりやすくする。**
プログラムに複雑な状態変化があり、それがファイルシステム上でひと目でわかるようになっていない場合、これをわかりやすくしておく必要がある。

例えば、`git status` は Git レポジトリの現状について、可能な限りの情報に加えて、その状態を変えるためのヒントもいくつか提示してくれる。

```
$ git status
On branch bfirsh/fix-delete
Your branch is up to date with 'origin/bfirsh/fix-delete'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   cli/pkg/cli/rm.go

no changes added to commit (use "git add" and/or "git commit -a")
```

**起動すべきコマンドをサジェストする。**
ワークフローがいくつかのコマンドで構成されている場合、次に起動すべきコマンドをいくつかサジェストしてあげると、プログラムの利用法の理解が進むし、新しい機能を発見するきっかけにもなる。
たとえば、上記の `git status` では、今見ている状態を変更するためのコマンドがいくつかサジェストされている。

**そのプログラムが境界線を超えて外の世界にアクションする場合は、明示的に行う。**
これには次のような事項が含まれる：

- 引数で明示的に指定していないファイルに対して読み書きする（キャッシュのような、そのプログラムの内部状態を保存するファイルは除く）
- リモートのサーバと通信する。例：ファイルのダウンロードなど。

**情報密度を増やす、アスキーアートで！**
例えば、`ls` はパーミッションを一覧で表示する。
初見ではほとんどの情報は無視できる。
仕組みがだんだんわかってくると、徐々に、より多くのパターンに気づくようになる。

```
-rw-r--r-- 1 root root     68 Aug 22 23:20 resolv.conf
lrwxrwxrwx 1 root root     13 Mar 14 20:24 rmt -> /usr/sbin/rmt
drwxr-xr-x 4 root root   4.0K Jul 20 14:51 security
drwxr-xr-x 2 root root   4.0K Jul 20 14:53 selinux
-rw-r----- 1 root shadow  501 Jul 20 14:44 shadow
-rw-r--r-- 1 root root    116 Jul 20 14:43 shells
drwxr-xr-x 2 root root   4.0K Jul 20 14:57 skel
-rw-r--r-- 1 root root      0 Jul 20 14:43 subgid
-rw-r--r-- 1 root root      0 Jul 20 14:43 subuid
```

**無造作に色を使わない。**
例えば、テキストの一部を目立たせるためにハイライトしたくなるかもしれないし、エラーの表示には赤字を使いたくなるかもしれない。
くれぐれもやりすぎないように。あらゆるものに色がついていると、色の意味がなくなってしまい、読みにくくなるだけだ。

**プログラムがターミナル上で使われていない場合、もしくはユーザがそう希望した場合は、色を使わない。**
以下のような場合は、色をオフにする：

- `stdout` または `stderr` が、対話式のターミナル（TTY）になっていない場合。
  個別に判断するのがベストだ。`stdout` が別のプログラムにパイプでつながれているのなら、`stderr` には色がある方がよい。
- 環境変数 `NO_COLOR` が指定されている場合。
- 環境変数 `TERM` の値として `dumb` が設定されている場合。
- オプション `--no-color` が指定されている場合。
- 特定のプログラムだけ色をオフにしたい場合に備えて、環境変数 `MYAPP_NO_COLOR` を追加してもいい。

_参考資料： [no-color.org](https://no-color.org/), [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)_

**`stdout` が対話式のターミナル出ない場合、アニメーションは表示しない。**
こうすれば、プログレスバーが、CI のログ出力にクリスマスツリーのような形で残ることはなくなる。

**わかりやすくなるならシンボルや絵文字を利用する。**
絵は言葉に勝ることもある。目立たせたいものがあるとか、注意を引きたいとか、あるいはちょっとキャラを立てたい、といったような場合だ。
ただし、ご注意を。たやすく度を越して、プログラムがごちゃごちゃしたり、おもちゃのように見えてしまったりする元になる。

例えば、[yubikey-agent](https://github.com/FiloSottile/yubikey-agent) は出力を構造化するために絵文字を使っているので、画面が文字だらけにならない。重要な情報には ❌ がついて、目立つようになっている。

```shell-session
$ yubikey-agent -setup
🔐 The PIN is up to 8 numbers, letters, or symbols. Not just numbers!
❌ The key will be lost if the PIN and PUK are locked after 3 incorrect tries.

Choose a new PIN/PUK: 
Repeat the PIN/PUK: 

🧪 Retriculating splines …

✅ Done! This YubiKey is secured and ready to go.
🤏 When the YubiKey blinks, touch it to authorize the login.

🔑 Here's your new shiny SSH public key:
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCEJ/
UwlHnUFXgENO3ifPZd8zoSKMxESxxot4tMgvfXjmRp5G3BGrAnonncE7Aj11pn3SSYgEcrrn2sMyLGpVS0=

💭 Remember: everything breaks, have a backup plan for when this YubiKey does.
```

**そのソフトウェアの制作者にしかわからないような情報は、デフォルトでは出さない。**
プログラムの挙動を、（制作者である）あなたが理解するためにしか役に立たない出力があるとしたら、それはほぼ確実に、デフォルトで通常のユーザに出してはならない情報だ。verboseモードの場合だけ出す。

外部の人や、プロジェクトの新規参加者に、ユーザビリティに関するフィードバックをもらえるよう呼びかけよう。
コードに近すぎるために、かえって気付けない重要な問題に気付かせてくれるだろう。

**`stderr` を（少なくともデフォルトでは）ログファイルのように使わない。**
ログレベルのラベル（`ERR`, `WARN`, etc.）を表示したり、余分なコンテキスト系の情報は表示しない。ただし vervose モードのときは例外だ。

**大量のテキストを出力するときは、ページャー（例： `less`）を利用する。**
例えば、`git diff` は、デフォルトでこうなっている。
ページャーはエラーも起こしやすいので、実装の際はユーザ体験が悪化しないように配慮すること。
`stdin` or `stdout` が対話式のターミナルにつながっていない場合はページャーを使ってはいけない。

`less` で使えるセンスのいいオプションは`less -FIRX` だ。
これで、1画面に収まる場合はページ分割せず、検索は大文字小文字を無視し、カラーと整形をオンにしてくれる上、 `less` 終了後も画面のコンテンツを消さずに残しておける。

言語によっては、`less` にパイプで渡すよりも確実なライブラリが整備されている可能性もある。
例えば、Python だと [pypager](https://github.com/prompt-toolkit/pypager) がそれにあたるだろう。

### エラー {#errors}

ドキュメントを参照したくなる理由としてもっともよくあるのは、エラーを修正したいときだ。
ドキュメントの中でエラーについても触れておけば、ユーザの時間を大幅に節約できるだろう。

**エラーを察知して [人間向きに書き換えること](https://www.nngroup.com/articles/error-message-guidelines/)。**
エラーの発生が予想される状況では、それを察知して、役に立つエラーメッセージに書き換えること。
会話と同じだと思えばよい。ユーザが間違ったことをしたら、プログラムが正しい方向に導いてあげるのだ。
例：「file.txtに書き込めません。 ‘chmod +w file.txt’ として、書き込み属性を付ける必要があるかもしれません。」

**シグナル／ノイズ比が肝心。**
無関係な出力をすればするほど、どこがよくなかったのかがユーザにわかるのに時間がかかるようになる。
プログラムが、同種のエラーを何回も出力しているような場合、わかりやすい見出しを立てて、その下にまとめて表示することを検討しよう。似たような行をたくさん出力しないこと。

**最初にユーザの目に留まるのはどこか考えよう。**
最重要の情報は出力の最後に出す。
赤色のテキストは目を引くので、よく考えて、適所に用いること。

**予期せぬエラー、または説明不可能なエラーが起きたときは、デバッグ情報とトレースバックを表示し、バグ報告のやり方を案内する。**
とはいうものの、シグナル／ノイズ比を忘れてはいけない。理解不能な情報でユーザを戸惑わせたくはないだろう。
デバッグ用ログはファイルに出力して、画面上には表示しないというやり方もある。

**バグ報告に手間がかからないようにする。**
ひとつうまいやり方として、URLを用意して、可能な限りの情報をあらかじめ埋めておくという方法がある。

### 引数とフラグ {#arguments-and-flags}

用語に関するメモ：

- _引数_, または _args_, は、コマンドに対する位置パラメータである。
  例えば、`cp` に与えるファイルパスは args である。
  args は、順番に意味があることが多い： `cp foo bar` は `cp bar foo` とは異なる意味を持つ。
- _フラグ_ とは、名前付きのパラメータで、1個のハイフンと1文字の名前（`-r`）か、もしくハイフン2個と複数文字の名前で指定する（`--recursive`）。
  ユーザが指定する値を含む場合もある（`--file foo.txt`、あるいは `--file=foo.txt`）。
  一般的に、フラグの指定順が違っても、プログラムの動作は変わらない。

**args よりフラグを優先する。**
タイプ量は増えるが、何が起こっているかは、はるかによくわかる。
将来、入力の受け付け方を変える場合も、こちらの方が楽だ。
args だと、新しい入力を追加する際に、既存の挙動が変わったり、あいまいさが生まれたりするしかない場合もある。

_引用: [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)._

**すべてのフラグに省略しない形も用意しておく。**
例えば、`-h` と `--help` の両方を用意しておく。
非省略形があれば、スクリプトをより詳細に、説明的に書くことができるので、いちいちフラグの意味を調べて回る必要がなくなる。

_引用: [GNU Coding Standards](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html)._

**1文字フラグは利用頻度の高いフラグだけに留める。** 特に、サブコマンドがある場合は、トップレベルだけに限定する。
こうすれば、短いフラグの名前空間が「汚染」されることがなくなり、将来追加するフラグに、複雑な文字列や大文字小文字を割り当てる必要がなくなる。

**複数のファイルをシンプルに操作する場合は、引数を複数にしてもよい。**
例えば `rm file1.txt file2.txt file3.txt`。
これはグロブでも有効になる： `rm *.txt`。

**2つ以上の引数が、それぞれ別の意味で使われている場合は、何かがおかしい。**
よくある、主要な操作は例外で、この場合は、省略が多くても覚える価値がある。
例えば、 `cp <source> <destination>`。

_引用: [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)._

**もし標準といえるものがあるのなら、フラグには標準的な名前を採用する。**
よく使われる他のコマンドがあるフラグを採用しているなら、その既存パターンを踏襲するのがベストだ。
こうすれば、ユーザはオプションを2通り（そして、どちらがどちらのコマンド用かも）覚える必要がなくなり、さらにヘルプを見なくても、オプションを推察することさえ可能になる。

よく用いられるオプションは、以下のようなものだ：

- `-a`, `--all`: すべて。
  例えば `ps`, `fetchmail`。
- `-d`, `--debug`: デバッグ用出力あり。
- `-f`, `--force`: 強制。
  例えば `rm -f` は、強制的にファイルを削除する。パーミッションで許可されていない場合であっても。
  これは、何か破壊的な操作を行うコマンドにも有用だ。通常はユーザの確認を求めるような操作でも、スクリプトの中では、その破壊的な操作を確認なしに実行したい場合がある。
- `--json`: JSON 形式で出力。
  [出力](#output) セクションを参照。
- `-h`, `--help`: ヘルプ。
  これはヘルプ以外の目的で使ってはならない。
  [ヘルプ](#help) セクションを参照。
- `--no-input`: [対話](#interactivity) セクションを参照。
- `-o`, `--output`: 出力ファイル。
  例えば `sort`, `gcc`。
- `-p`, `--port`: ポート番号。
  例えば `psql`, `ssh`。
- `-q`, `--quiet`: 省出力。
  表示出力を少なくする。
  これは、人間向けに表示している出力を、スクリプトで実行する場合は隠したい場合に特に有用だ。
- `-u`, `--user`: ユーザ名。
  例えば `ps`, `ssh`。
- `--version`: ヴァージョン。
- `-v`: こちらは、verbose を意味する場合と、ヴァージョンを意味する場合がある。
  verbose には `-d` を当て、こちらはヴァージョンに当てる、もしくは、混乱を避けるために、このオプションには何も割り当てないという手もある。

**デフォルトは大部分のユーザーに適したものにしておく。**
設定を変えられるのはいいが、ほとんどのユーザーは正しいフラグを探したり、忘れずにそれを毎回付けたり（あるいはそのフラグ付きでエイリアスに）はしてくれない。
デフォルトがそうなっていなければ、大部分のユーザーにとって不快な体験となるだろう。

例えば、`ls` のデフォルトでの出力は簡素で、スクリプトやその他の歴史的事情に最適化されている。だが、もし今設計するなら、デフォルトはたぶん `ls -lhFGT` になっていただろう。

**プロンプトでユーザーの入力をうながす。**
引数やフラグが付いていなかったら、プロンプトを出してうながそう。
（こちらも参照: [Interactivity](#interactivity)）

**プロンプトは _必須_ にしないこと。**
いかなる場合も、入力値をフラグや引数で渡せるようにしておく。
対話式ターミナルの入力が `stdin` でない場合は、プロンプトは出さず、フラグや引数を必須にする。

**危険な操作の前には確認する。**
よくあるやり方としては、対話式で利用しているときは、プロンプトを出してユーザーに `y` か `yes` とタイプとさせ、そうでないときは `-f` か `--force` を渡してもらうという方法だ。

「危険」というのは主観的な単語なので、どの度合いにもいくつかのレベルがある：

- **軽度：** ファイルの消去のような、小規模でローカルな変更。
  確認のプロンプトが欲しいときもあれば、そうでないときもある。
  例えば、ユーザーが「delete」といったような名称のコマンドを起動したときは、聞き直す必要なないだろう。
- **中度：** ディレクトリの消去のような、より大規模なローカルでの変更。リソースの消去などのリモートの変更、あるいは取り消しが難しい複雑で大規模な変更。
  この場合は、確認のプロンプトを出すのが普通だ。
  操作を「dry run」できるようにしておくことも考慮しよう。こうすれば、、実際に実行する前に何が起こるかを確認できる。
- **重度：** リモートにあるアプリケーションやサーバー全体など、複雑なものの消去。
  この場合、確認のプロンプトを出すだけでは不十分で、うっかりと簡単に確認できないようにもしておくべきだ。
  簡単にはタイプできないもの、例えば今から消去しようとしているものの名称を入力させるのもひとつのやり方だ。
  この場合も、`--confirm="name-of-thing"` のように、フラグで渡せるようにしておけばスクリプトにも対応できる。

気づかないうちに、何かをうっかり破壊してしまうことがないように配慮する。
例えば、設定ファイルの数値を10から1に変更すると、暗黙で9つの何かが消去されてしまうような場合、これを重大なリスクと捉えて、うっかりそうならないように工夫する。

**入力または出力がファイルの場合、`-` で`stdin` からの読み込んだり、`stdout` への書き込みができるようにする。**
これにより、別のコマンドの出力をこのプログラムの入力とする、またはその逆も可能になり、テンポラリーファイルを作る必要がなくなる。
例えば、`tar` は `stdin` から読み込んだファイルを展開することができる：

```
$ curl https://example.com/something.tar.gz | tar xvf -
```

**フラグにオプション値を渡せる場合、「none」のような特殊な単語も使えるようにしておく。**
例えば、`ssh -F` には、オプションとして `ssh_config` の代替となるファイル名を与えることができ、`ssh -F none` とすることで、設定ファイルなしで SSH を起動できる。値として空白を認めてしまうと、引数がフラグの値なのか、引数なのかがあいまいになる。

**可能なら、引数、フラグ、サブコマンドの並び順は自由とする。**
CLI の多く、特にサブコマンドを持つ場合は、様々な引数の置き場所について不文律がある。
例えば、`--foo` というフラグは、サブコマンドの前に置いた場合のみ有効、といったようなものだ。

```
mycmd --foo=1 subcmd
有効

$ mycmd subcmd --foo=1
unknown flag: --foo（エラー）
```

これは大変な混乱の元だ。特に、コマンドを起動するユーザーがよくやる行動で、上カーソルキーで前の起動時のコマンドを呼び出して、おしりにオプションを付け足してまた起動する場合に問題となる。
可能ならば、両方の形式を等価に扱いたい。引数パーサーの限界にぶち当たるかもしれないが。

**機密情報はフラグから直接読み込まない。**
あるコマンドが、例えば、 `--password` 引数を経由して機密情報を受け取るとき、
引数の値は `ps` の出力や、場合によってはシェル履歴にも残るので、そこから機密情報が漏洩する。
また、この手のフラグがあると、安全でない環境変数に機密情報を設定する悪弊を助長することにもなる。

機密性の高いデータはファイル経由でのみ受け付ける方式を検討してみよう。例えば `--password-file` 引数や、`STDIN` 経由で受け取るのである。
`--password-file` 引数なら秘密情報はこっそり渡せるし、様々な状況にも対応できる。

（確かに、Bashなら、ファイルの中身を引数に渡すことはできる `--password $(< password.txt)`。
このアプローチでは、ファイルの中身を `ps` の出力などにさらしてしまうという、先ほどのセキュリティ問題が解決できない。
避けるのが賢明だ。）

### 対話性 {#interactivity}

**プロンプトや対話的な要素は、 `stdin` が対話式ターミナル（TTY）になっているときにだけ利用する。**
データをパイプでコマンドに流し込んでいるか、あるいはスクリプトで実行しているかを判断するには、これがかなり確実な手法である。この場合、プロンプトは役に立たないので、エラーを吐いて、どんなフラグを渡すべきかをユーザーに提示しよう。

**`--no-input` と指定されたら、プロンプトその他の対話的挙動は一切しないこと。**
こうすれば、ユーザーが、コマンド中のプロンプトを、すべて明示的にオフにできる。
コマンドに必須の入力がある場合は、エラーを出して、その情報をフラグの形で渡す方法を提示しよう。

**プロンプトでパスワードを求める場合は、入力値をそのまま表示しないこと。**
端末のエコーを切れば、これは実現できる。
どの言語にもこのための手段があるはずだ。

**脱出方法を用意する。**
コマンドから抜ける方法を明示する。
（この点では vim を真似てはいけない。）
ネットワークのI/Oなどでプログラムがハングしてしまった時でも、Ctrl-C だけは効くようにしておく。
プログラム実行にラッパーを使っていると Ctrl-C で止められないが（SSH、tmux、telnet など）、どうすればよいかは明示しておく。
例えば、SSH では、`~` をエスケープキャラクターとして、エスケープシーケンスを利用できる。

### サブコマンド

相当に複雑なツールの場合、いくつかのサブコマンドを設けることで、その複雑性を緩和できる。
非常に関連性の高いツールがいくつかある場合、それらをひとつのコマンドにまとめてしまったほうが使いやすくなるし、探しやすくなる（例えば、RCS と Git の違い）。

グローバルのフラグ、ヘルプテキスト、設定、ストレージの仕組みなど、何かを共有する際に有益だ。

**サブコマンド間の一貫性を保つ。**
同じことは同じフラグ名で表す、出力のフォーマットを統一する、など。

**サブコマンドに階層がある場合、名前に一貫性を持たせる。**
複雑なソフトウェアで、オブジェクトがたくさんあって、そのオブジェクトの操作も多様な場合、サブコマンドを2階層にするのが一般的なパターンだ。そのひとつは名詞、もうひとつは動詞である。
例えば `docker container create` がこれにあたる。
オブジェクトのタイプが変わっても、動詞には一貫性を持たせること。

`名詞 動詞` でも `動詞 名詞` でも、順番はどちらでもよいが、`名詞 動詞` の方が一般的だ。 

_参考: [User experience, CLIs, and breaking the world, by John Starich](https://uxdesign.cc/user-experience-clis-and-breaking-the-world-baed8709244f)._

**あいまいな、あるいは似た名前のコマンドは避ける。**
例えば、サブコマンドに「update」と「upgrade」というのがあると、非常にまぎらわしい。
違う言葉を使うか、追加の言葉を補ってあいまいさを解消するとよいだろう。

### 堅牢性 {#robustness-guidelines}

**ユーザーの入力値を検証する。**
ユーザーのデータを受け取るプログラムは、いずれダメなデータを食わされる運命にある。
早めにチェックして立て直し、ダメなことが起こらないようにしよう。また、[エラーは理解しやすくしておくこと](#errors)。

**反応の速さはスピードより重要。**
100ミリ秒以下で何か出力すること。
ネットワーク経由でリクエストを送るなら、その手前で何か出力する。こうすれば、ハングして壊れたように見えなくて済む。

**時間のかかる処理は進行状況を表示する。**
プログラムが長時間何も出力しないと、壊れたしたように見える。
よくできたスピナーやプログレスインジケーターを利用すれば、プログラムが、実際より早く動作しているように見せることができる。

Ubuntu 20.04 のプログレスバーは、ターミナルの底辺にくっつく気の利いた仕様になっている。

<!-- (TK reproduce this as a code block or animated SVG) -->

プログレスバーが長時間、1箇所で止まっていると、まだ動作しているのか、プログラムがクラッシュしてしまったのか、ユーザーには見分けがつかない。
残り時間の予想を表示するか、あるいは動きのある部品を配置しておくとよい。まだ動作している、ということがしっかり伝えられる。

プログレスバーの実装には、よいライブラリがたくさんある。
例えば、Pythonなら[tqdm](https://github.com/tqdm/tqdm) 、Goなら[schollz/progressbar](https://github.com/schollz/progressbar)、Node.jsなら[node-progress](https://github.com/visionmedia/node-progress) が挙げられる。

**なるべく並行処理を心がける。ただし、よく考えて。**
シェルでは、単に進行状況を表示するだけでも、すでに大仕事である。並行処理でそれをやろうとすると、10倍は難しくなる。
堅牢性を意識し、出力が交錯して混乱を招かないようにしよう。
ライブラリが利用できるなら、そうしよう。自分で書きたくなるようなコードではないからだ。
Pythonの[tqdm](https://github.com/tqdm/tqdm) や、Goの[schollz/progressbar](https://github.com/schollz/progressbar)といったライブラリでは、複数のプログレスバーをネイティブでサポートしている。

ユーザビリティが大幅に向上するのが利点である。
例えば、 `docker pull` では、複数プログレスバーのおかげで、現在の進行状況がよくわかる。

```
$ docker image pull ruby
Using default tag: latest
latest: Pulling from library/ruby
6c33745f49b4: Pull complete 
ef072fc32a84: Extracting [================================================>  ]  7.569MB/7.812MB
c0afb8e68e0b: Download complete 
d599c07d28e6: Download complete 
f2ecc74db11a: Downloading [=======================>                           ]  89.11MB/192.3MB
3568445c8bf2: Download complete 
b0efebc74f25: Downloading [===========================================>       ]  19.88MB/22.88MB
9cb1ba6838a0: Download complete 
```

注意したいこととして、_うまく_ いっているときは、プログレスバーを出して、ログは出さない方が、進行状況がわかりやすい。だが、エラーが起きたら、ログを出力すべきだ。
でないと、デバッグが非常に難しくなる。

**タイムアウトするようにしておく。**
ネットワークのタイムアウト（待機時間）は変えられるようにしておく。適切なデフォルトを設定しておけば、永久にハングしたまま、ということはなくせる。

**冪等性を持たせること。**
一時的な理由（例えば、ネットワークの遮断）でプログラムが止まったとしても、 `<up>` や `<enter>` で途中から再開できるようにしておく。

**クラッシュオンリーにする。**
冪等性をさらに一歩進めよう。
処理が終わったあと、特に終了処理が要らない場合、または、次回起動時までほっておいても構わない場合、失敗したり、邪魔が入った時点ですぐに終了しよう。
これにより、さらに堅牢で、反応のいいプログラムになる。

_引用元: [Crash-only software: More than meets the eye](https://lwn.net/Articles/191059/)._

**間違った使い方をされる前提で作る。**
心して備えよう。
スクリプトに組み込まれるかもしれないし、劣悪なネット環境で利用されるかもしれない。一度に多数のインスタンスを立ち上げるかもしれないし、テストしなかった環境で利用されるかもしれない。しかも、想定外の仕様だってあるかもしれない。
（macOS のファイルシステムは大文字と小文字を区別しないけど、表示上は大文字と小文字を使い分けられるって知ってた？）

### 将来に備える {#future-proofing}

いかなるソフトウェアであれ、インターフェイスを変えるとなれば、十分な時間とドキュメントを備えた移行期間抜きでは考えられない。
サブコマンド、引数、フラグ、設定ファイル、環境変数。これらはすべてインターフェイスだ。よって、これらの動作は保証しなくてはならない。
（[セマンティック・ヴァージョニング](https://semver.org/) は、変更の大きさの言い訳にしかならない。毎月大規模な変更をしていたら、意味がない。）

**できるなら、変更は追加式で。**
既存のフラグを後方互換性のない形で変更するよりは、新しいフラグを追加することを考えよう。ただし、インターフェイスが肥大化しないように。
（[引数とフラグ](#arguments-and-flags) の項を参照。）

**追加式でない変更は慎重に。**
いつか、インターフェイスの変更を余儀なくされる日が来るだろう。
実施する前に、プログラム内でユーザーに警告しよう。廃止予定のフラグを使ったら、もうすぐ変更になることを告知する。
今すぐ将来に備えられるような方法を用意しておき、そのやり方を知らせよう。

可能なら、対応済みのユーザーには、それ以上警告は出さないようにする。こうすれば、最終的に変更が実施されても、ユーザーはそれに気付くこともないだろう。

**人間向けの出力にしておけば、まず間違いない。**
インターフェイスを使いやすくするには、何度もやり直すしかない。だが出力をインタフェースと考えるなら、やり直しは効かない。
スクリプトでは `--plain` や `--json` を使うように推奨して、出力を安定したものにしよう（[出力](#output) を参照）。

**何でもOKのサブコマンドは作らない。**
あるサブコマンドの利用頻度がもっとも高い場合、つい、簡潔さのためにそれを省略できるようにしたくなる。
例えば、任意のシェルコマンドをラップする `run` というコマンドがあるとしよう。

    $ mycmd run echo "hello world"

`mycmd` の最初の引数が、既存のどのサブコマンドにも該当しない場合、`run` が指定されたものとみなして、以下のような書式を許したくなる：

    $ mycmd echo "hello world"

だが、これには深刻な欠点がある。`echo` というサブコマンド（あるいは _それ以外の何であれ_）は、もう作れなくなるのだ。やるとすれば、既存の利用方法を破壊するリスクを負うことになる。
`mycmd echo` という記述のあるスクリプトは、そのツールを新ヴァージョンにアップグレードした途端、まったく挙動が変わってしまう。

**サブコマンドを好きなように省略させない。**
`install` というサブコマンドを備えたコマンドがあるとしよう。
これを実装する際に、ユーザーのタイピングを少しでも楽にするために、意味さえ通れば、頭の何文字をタイプしてもいいようにして `mycmd ins` 、あるいはもっと縮めて  `mycmd i` としても、`mycmd install` のエイリアスと認めるようにしたとしよう。
こうなると頭打ちだ。`i` で始まるコマンドは今後一切作れない。なぜなら、`install` の代わりに `i` を使っているスクリプトが世界中にあるからだ。

エイリアス自体は悪くない。タイプ量を減らすのはよいことだ。だが、それは明示的にやるべきだし、安定的でもあるべきだ。

**「時限爆弾」を作らない。**
今から20年後を想像してほしい。
君のコマンドは、今と同じように動作しているだろうか？あるいは、ネット上にある外部の依存先が変わったり、メンテナンスされなくなったりして、動作しなくなっているだろうか？
20年後になくなっている確率が最も高いのは、今、君がメンテナンスしているサーバーだ。
（だからといって、処理の前に Google Analytics の応答を待つ、なんてコードは書かないように）

### シグナルと制御文字 {#signals}

**Ctrl-C （INT シグナル）が押されたら、できるだけすぐに終了する。**
終了処理をする前に、取り急ぎ何か表示する。
終了処理にはタイムアウトを設け、永久にハングすることがないようにする。

**長い終了処理の途中で Ctrl-C が押されたら、無視する**
再度 Ctrl-C が押されたら、破壊的な挙動になる場合は、そのあとどうなるかを表示する。

例えば、Docker Composeを終了する際に、 Ctrl-C を2度押すと、コンテナーは手順通りにシャットダウンせず、ただちに停止する。

```
$  docker-compose up
…
^CGracefully stopping... (press Ctrl+C again to force)
```

プログラムは、終了処理が実行されていない状態で起動される場合も想定しておくべきである。
（ [Crash-only software: More than meets the eye](https://lwn.net/Articles/191059/) 参照）

### 設定 {#configuration}

コマンドライン・ツールには数多くの違った種類の設定があり、その指定方法にも多くの違ったやり方がある（フラグ、環境変数、プロジェクト単位の設定ファイル）。
それぞれの設定にベストな指定方法を割り当てる上で、関係する要因は、それほど多くない。主なものは _特異性_、 _安定性_ それに _複雑性_ だ。

設定は、一般的にいくつかのカテゴリーに分かれる：

1. コマンドを起動するたびに異なる。

    例：

    - デバッグ出力のレベル設定
    - セーフモード、あるいは dry run の有効化

    おすすめ：**[フラグ](#arguments-and-flags) を利用する。**
    場合によっては、[環境変数](#environment-variables) も便利だろう。

2. 何度起動しても通常は安定しているが、例外もある。
    プロジェクトごとに異なる場合がある。
    当然ながら、同じプロジェクトでも、ユーザーによって異なる。

    このタイプの設定は、端末によって異なることも多い。

    例：

    - プログラムの起動に必要なアイテムのPathがデフォルトとは異なる
    - 出力を色分けするかどうかの指定
    - すべてのリクエストが経由する HTTP プロクシサーバーの指定

    おすすめ：**[フラグ](#arguments-and-flags) を使うか、または [環境変数](#environment-variables) でもいいかもしれない。**
    グローバルで有効にできるので、シェルのプロファイルで変数を設定したいユーザーもいるだろう。特定のプロジェクトだけなら `env` にするかもしれない。

    この設定が相当複雑な場合、それだけで設定ファイルを用意する理由になる。だが、たいていは環境変数で十分だ。

3. プロジェクト内では、ユーザーによらず安定している。

    これは、ヴァージョン管理されるようなタイプの設定である。
    `Makefile`、 `package.json` それに `docker-compose.yml` といったファイルは、すべてこの例になる。

    おすすめ：**コマンドごとにヴァージョン管理されたファイルを使用する。**

**XDG 仕様に準拠する。**
2010年に、X Desktop Group、現在の [freedesktop.org](https://freedesktop.org) が開発した仕様には、設定ファイルの置き場となる基本的なディレクトリの位置が規定されている。
その目標のひとつは、ユーザーのホームディレクトリがドットファイルであふれないようにすることで、そのために汎用の `~/.config` フォルダが設けられた。
「The XDG Base Directory Specification」（[仕様原本](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)、 [要約](https://wiki.archlinux.org/index.php/XDG_Base_Directory#Specification)）は、yarn、 fish、 wireshark、 emacs、 neovim、 tmux、その他、有名で愛用者の多い数多くのプロジェクトで採用されている。

**他のプログラムの設定を自動で書き換える場合は、ユーザーの同意を求め、何をするつもりなのかを正確に伝えること。**
既存の設定ファイルに追記する（例： `/etc/crontab`）よりも、新しい設定ファイルを作る（例： `/etc/cron.d/myapp`）方が好ましい。
システム共通の設定ファイルに追記、または変更を加える場合は、何を追加したのか、そのファイルに日付付きのコメントで残しておく。

**優先順位に従って設定を適用する。**
設定パラメーターの優先順位は、高いものから低いものに、以下の順で扱う：

- フラグ
- 実行中シェルの環境変数
- プロジェクトごとの設定（例： `.env`）
- ユーザーごとの設定
- システム共通の設定

### 環境変数 {#environment-variables}

**環境変数はコマンドを起動する _コンテキストによって異なる_ 挙動のためのものである。**
環境変数の「環境」とは端末セッションのことで、コマンドが起動されるコンテキストのことである。
だから、環境変数はコマンドを起動するたびに変わっているかもしれないし、同じプロジェクトのインスタンスでもマシンによって異なるかもしれない。

環境変数はフラグの内容や、設定パラメーターを複写するかもしれないし、これらには影響を受けないかもしれない。
代表的なタイプの設定の解説や、環境変数がもっともお勧めできる場合については [設定](#configuration) の項を参照のこと。

**移植性を最大化するために、環境変数の名称は大文字と数字、アンダースコアのみとする（1文字目は数字にしない）。**
というわけで、環境変数名に使える顔文字は `O_O` と `OWO` だけ、ということになる。

**環境変数の値は改行なしを原則とする。**
複数行も可能だが、`env` コマンドでユーザビリティ上の問題が出る。

**広く利用されている名称とかぶらないようにする。**
こちらが [POSIX 標準環境変数リスト](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html) である。

**可能なら汎用の環境変数を設定値として採用する：**

- `NO_COLOR`、カラー出力を抑止（[出力](#output)を参照
- `DEBUG`、より頻繁な出力
- `EDITOR`、ファイルの編集や複数行の入力が必要な場合
- `HTTP_PROXY`、 `HTTPS_PROXY`、 `ALL_PROXY` それに `NO_PROXY`、ネットワーク経由の操作に
  （利用している HTTP ライブラリがすでに確認済みかも。）
- `SHELL`、対話的セッションやユーザー指定のシェルを開く場合
  （シェルスクリプトを実行するなら、 `/bin/sh` のようにインタープリターは指定しておく）
- `TERM`、 `TERMINFO` それに `TERMCAP`、ターミナル用のエスケープシーケンスを使う時
- `TMPDIR`、一時ファイルを作成する場合
- `HOME`、設定ファイルの設置場所として
- `PAGER`、ページ単位で出力したい場合
- `LINES` それに `COLUMNS`、画面サイズによって出力を変えたい場合（表形式など）

**状況によっては環境変数を `.env` から取得する。**
特定のディレクトリで作業している限り、コマンドが設定している環境変数に変更の可能性がない場合、
ローカルの `.env` ファイルからも読み込めるようにした方がよい。毎回設定し直さなくても、プロジェクトごとに異なった設定にできるからだ。
`.env` ファイルを読み込むライブラリは多くの言語に用意されている （[Rust](https://crates.io/crates/dotenv)、 [Node](https://www.npmjs.com/package/dotenv)、 [Ruby](https://github.com/bkeepers/dotenv)）。

**`.env` を正式の [設定ファイル](#configuration) の代わりにしてはいけない。**
`.env` ファイルには多くの制約がある：

- `.env` ファイルは、ソース管理されないことが多い
- （よって、そこに保存された設定には履歴もないことになる）
- データの型がひとつしかない：string（文字列）
- 記載が乱雑になりやすい
- エンコードが問題になりやすい
- 本来もっと慎重に扱うべき機密性の高いクレデンシャルやキーなどを含むことが多い

こうした制約からユーザビリティやセキュリティが犠牲になるようなら、専用の設定ファイルを用意した方がいいだろう。

**機密情報は環境変数から読み込まない。**
環境変数は機密情報を保存するのに便利だが、漏洩の危険性が実証されている：
- 環境変数を export すると、すべてのプロセスに送られてしまう。そこから簡単にログに漏洩したり、抜き取られたりする
- シェル置換、例えば `curl -H "Authorization: Bearer $BEARER_TOKEN"` のような操作は、グローバルに読み取り可能なプロセス状態に漏洩する。
  （cURL には `-H @filename` という代替手段があり、機密性の高いヘッダーをファイルから読み取れるようになっている）
- Docker コンテナの環境変数は、Docker デーモンにアクセスできる人なら、誰でも `docker inspect` で閲覧できる
- systemd ユニットの環境変数は `systemctl show` で、グローバルに読み取り可能

機密情報は、クレデンシャル・ファイル、パイプ、 `AF_UNIX` ソケット、機密管理サービス、あるいはその他の IPC 機構からのみ受け付けるようにするべきだ。
### ネーミング {#naming}

CLIでは、プログラムの名前はことのほか重要だ。ユーザーはいつもそれをタイプすることになるからだ。覚えやすく、タイプしやすいことが求められる。

**シンプルで覚えやすい単語にする。**
だたし、あまり一般的すぎてもいけない。他のコマンドと競合してユーザーを困らせることになるからだ。
例えば、ImageMagick と Windows には、どちらにも `convert` というコマンドがある。

**使うのは小文字のみ、やむを得ない場合だけダッシュを使う。**
`curl` はよい名前だが `DownloadURL` はよくない。

**短くする**
ユーザーはいつもそれをタイプすることになる。
短か _すぎる_ のはよくない：極端に短いコマンドは、頻繁に使われるユーティリティに当てるべきだからだ。例えば、 `cd`、 `ls`、 `ps` がこれにあたる。

**タイプしやすくする**
ある種の単語はQWERTYキーボードで非常に打ちやすく、それは単に簡潔と言うにとどまらない。
`plum` は簡潔かもしれないが、面倒で飛び飛びになる。
`apple` は同じ文字の連打ではまりやすい。
`orange` はこれらより長いが、ずっと打ちやすい。

_参考資料： [The Poetics of CLI Command Names](https://smallstep.com/blog/the-poetics-of-cli-command-names/)_

### 配布 {#distribution}

**可能なら単一のバイナリで配布する。**
標準ではバイナリ実行ファイルにコンパイルできない言語の場合、[PyInstaller](https://www.pyinstaller.org/) のような仕組みがないか調べてみよう。
どうしても単一のバイナリで配布できない場合、各プラットフォーム用のパッケージ・インストーラーを利用して、ディスク上に削除しにくいもの撒き散らさないようにする。
他人のPCに土足で踏み入らないこと。

特定の言語専用のツール、例えばコードリンターのようなものは、このルールの例外になる。なぜなら、その言語用のインタープリターは、すでにユーザーのコンピューターにインストール済みであると期待できるからだ。

**簡単にアンインストールできるようにする。**
手順が必要なら、インストール手順の最後に、そのことにも触れておく。ソフトウェアをインストールした直後に、アンインストールしたくなることがよくある。

### ログ解析 {#analytics}

利用状況を測定すれば、ユーザーがプログラムをどのように使用しているか、どうすればより良くなるか、どこに力を入れるべきかを理解するのに役立つ。
だが、ウェブサイトとは違って、コマンドラインのユーザは自分の環境をコントロールできるのが当然と考えているため、プログラムがこっそりとバックグランドで何かをしていると驚いてしまう。

**同意なしに利用状況やクラッシュ時のデータを収集しない。**
いつか見つかって、ユーザーを怒らせることになるだろう。
収集する対象、収集する理由、匿名性の程度、匿名化の手段、さらにその保持期間をはっきりと明示する。

できるなら、ユーザーにデータ提供の意志を確認すること（オプトイン）。
デフォルトで取得する（オプトアウト）なら、ウェブサイトや初回起動時にそのことを明確に伝え、解除しやすいようにしておく。

利用状況の統計データを収集しているプロジェクトの例：

- Angular.js は、機能の優先順位付けのため、という名目で [Google Analytics を使って詳細なログを収集している](https://angular.io/analytics)。
  明示的なオプトインとなっている。
  トラッキング ID はユーザー自身の Google Analytics のプロパティを指すように変更できるので、自分の組織内での Angular の利用状況をみることもできる。
- Homebrew は計測データを Google Analytics に送っており、 [よくできた FAQ](https://docs.brew.sh/Analytics) で、その内容を詳細に説明している。
- Next.js は [利用状況のデータを匿名化して収集](https://nextjs.org/telemetry) しており、デフォルトで有効になっている。

**ログ収集の代替手段を考える。**

- ウェブ上のドキュメントを利用する。
  CLIツールの利用状況を知りたければ、もっとも知りたいユースケースを中心にドキュメントを揃えておき、それらのパフォーマンスを時系列で見ていく。
  ドキュメント内でどんな言葉で検索されているかを見る。
- ダウンロードを利用する。
  大ざっぱではあるが、利用状況と、ユーザーの使用 OS を理解する指標にはなる。
- ユーザーと対話する。
  ツールがどのように利用されているか、ユーザーに聞いてみよう。
  ドキュメントやレポジトリでも、フィードバックや機能要望を奨励し、フィードバックしてくれた人から、より多くの情報を引き出すようにする。

_参考資料： [Open Source Metrics](https://opensource.guide/metrics/)_

## 参考資料

- [The Unix Programming Environment](https://en.wikipedia.org/wiki/The_Unix_Programming_Environment), Brian W. Kernighan and Rob Pike
- [POSIX Utility Conventions](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html)
- [Program Behavior for All Programs](https://www.gnu.org/prep/standards/html_node/Program-Behavior.html), GNU Coding Standards
- [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46), Jeff Dickey
- [CLI Style Guide](https://devcenter.heroku.com/articles/cli-style-guide), Heroku
